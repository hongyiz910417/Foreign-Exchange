package decisionTree;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

import constants.Params;
import measure.Measure;
import measure.MeasureFactory;
import measure.MeasureType;
import treenode.TreeNode;

public class DecisionTree {
	private TreeNode root;
	private static final int DIVIDE_COUNT = 10;
	
	public void buildTree(String filename){
		Measure measure = MeasureFactory.getMeasure(MeasureType.PLUS_MEASURE);
		
	}
	
	private int[] getMaxMin(String filename){
		double[] results = new double[Params.FEATURE_COUNT * 2]; // 0: max, 1: min
		for(int i = 0; i < Params.FEATURE_COUNT * 2; i++){
			if(i % 2 == 0)
				results[i] = 0;
			else
				results[i] = Double.MAX_VALUE;
		}
		try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
		    String line;
		    while ((line = br.readLine()) != null) {
		       String[] cols = line.split(",");
		       double bidMin = Double.parseDouble(cols[2]);
		       double bidMax = Double.parseDouble(cols[3]);
		       double bidAvg = Double.parseDouble(cols[4]);
		       double spreadAvg = Double.parseDouble(cols[5]);
		       
		       results[0] = Math.max(results[0], bidMin);
		       
		    }
		    br.close();
		    int count1 = 0, count2 = 0;
		    if(trueS1Count < falseS1Count){
		    	count1 = falseS1Count;
		    	count2 = trueS2Count;
		    }
		    else{
		    	count1 = trueS1Count;
		    	count2 = falseS2Count;
		    }
		    return count1 + count2;
		} catch(IOException e){
			e.printStackTrace();
		}
	}
}
