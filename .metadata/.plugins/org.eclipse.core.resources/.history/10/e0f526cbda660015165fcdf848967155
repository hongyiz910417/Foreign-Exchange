package decisionTree;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

import Utils.util;
import constants.Params;
import measure.Measure;
import measure.MeasureFactory;
import measure.MeasureType;
import treenode.FeatureNode;
import treenode.TreeNode;

public class DecisionTree {
	private TreeNode root;
	private static final int DIVIDE_COUNT = 10;
	
	public void buildTree(String filename){
		Measure measure = MeasureFactory.getMeasure(MeasureType.PLUS_MEASURE);
		List<String> lines = util.readfile(filename);
		Queue<List<String>> lineQueue = new LinkedList<List<String>>();
		Queue<TreeNode> nodeQueue = new LinkedList<TreeNode>();
		root = new FeatureNode(null, null, 0.0, 2);
		nodeQueue.offer(root);
		lineQueue.offer(lines);
		while(!nodeQueue.isEmpty()){
			TreeNode node = nodeQueue.poll();
			List<String> nodeLines = lineQueue.poll();
			if(node instanceof FeatureNode){
				FeatureNode featureNode = (FeatureNode)node;
				int colIndex = featureNode.getColIndex();
				double[] maxMin = getMaxMin(nodeLines, colIndex);
				double delta = (maxMin[0] - maxMin[1]) / DIVIDE_COUNT;
				double maxPerformance = 0;
				double bestPoint = 0;
				for(int i = 1; i < DIVIDE_COUNT; i++){
					double splitPoint = maxMin[1] + delta * i;
					double performance = measure.measureSplit(splitPoint, nodeLines
							, colIndex);
					if(performance > maxPerformance){
						maxPerformance = performance;
						bestPoint = splitPoint;
					}
				}
				featureNode.setSplitPoint(bestPoint);
				List[] lists = split(bestPoint, nodeLines, colIndex);
				
			}
		}
	}
	
	private List[] split(double splitPoint, List<String> lines, int colIndex){
		List<String> list1 = new ArrayList<String>();
		List<String> list2 = new ArrayList<String>();
		for(String line : lines) {
			String[] cols = line.split(",");
		    double val = Double.parseDouble(cols[colIndex]);
		    if(val < splitPoint){
		    	list1.add(line);
		    }
		    else{
		    	list2.add(line);
		    }
		}
		List[] lists = new List[2];
		lists[0] = list1;
		lists[1] = list2;
		return lists;
	}
	
	private boolean getLabel(List<String> lines){
		int trueCount = 0;
		for(String line : lines) {
			String[] cols = line.split(",");
			boolean label = Boolean.parseBoolean(cols[Params.LABEL_INDEX]);
			if(label){
				trueCount++;
			}
		}
		return trueCount > lines.size() / 2);
	}
	
	private double[] getMaxMin(List<String> lines, int colIndex){
		double[] results = new double[2]; // 0: max, 1: min
		results[0] = 0;
		results[1] = Integer.MAX_VALUE;
	    for(String line : lines) {
	       String[] cols = line.split(",");
	       double val = Double.parseDouble(cols[colIndex]);
	       results[0] = Math.max(results[0], val);
	       results[1] = Math.min(results[1], val);
	    }
		return results;
	}
}
